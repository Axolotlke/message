<?php
// $Id: message.module,v 1.12 2010/06/07 10:54:11 amitaibu Exp $

/**
 * @file
 * API functions to manipulate messages.
 */

/**
 * Minimum CTools version needed.
 */
define('MESSAGE_REQUIRED_CTOOLS_API', '2.0-alpha1');

/**
 * Implementation of hook_ctools_plugin_api().
 */
function message_ctools_plugin_api($module, $api) {
  if ($module == 'message' && $api == 'plugins') {
    return array('version' => 1);
  }
}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function message_ctools_plugin_directory($module, $type) {
  // Safety: go away if CTools is not at an appropriate version.
  if (!module_invoke('ctools', 'api_version', MESSAGE_REQUIRED_CTOOLS_API)) {
    return;
  }

  if ($module =='message' && $type == 'plugins') {
    return 'plugins/message';
  }
  elseif ($type =='export_ui') {
    return 'plugins/export_ui';
  }
}

/**
 * Implementation of hook_views_api().
 */
function message_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'message') . '/includes',
  );
}

/**
 * Implementation of hook_features_api().
 */
function message_features_api() {
  return array(
    'message' => array(
      'name' => 'Messages',
      'api' => 'message',
      'default_hook' => 'message_default_messages',
      'current_version' => 1,
      'module' => 'message',
      'feature_source' => TRUE,
    ),
  );
}

/**
 * Implementation of hook_theme().
 */
function message_theme() {
  // Safety: go away if CTools is not at an appropriate version.
  if (!module_invoke('ctools', 'api_version', MESSAGE_REQUIRED_CTOOLS_API)) {
    return;
  }

  $items = array();
  $items['message'] = array(
    'arguments' => array('message' => array()),
  );
  return $items;
}

/**
 * Implementation of hook_views_pre_render().
 *
 * In order to reduce the database hits, we take advantage of the fact that we
 * know the message instances IDs before they are rendered. We load them all,
 * and they are saved in a static cache. So later when they are rendered, the
 * message instances are already cached.
 *
 * @see message_instance_load_multiple().
 * @see message_show_message().
 */
function message_views_pre_render(&$view) {
  // Define if this is a view that involves message instance, and thus should be
  // processed.
  $process = FALSE;
  $ids = array();
  // Look for a field that belong to the {message_instance} table.
  foreach ($view->field as $field) {
    if ($field->definition['handler'] == 'message_handler_field_message_render') {
      $field_alias = $field->field_alias;
      $process = TRUE;
      break;
    }
  }
  if ($process && !empty($view->result)) {
    foreach ($view->result as &$row) {
      $ids[] = $row->{$field_alias};
    }
  }

  // Load the message instances, so they will be statically cached.
  if ($ids && $message_instances = message_instance_load_multiple($ids)) {
    $remove = array();
    foreach ($message_instances as $key => $value) {
      // Check if messages should be hidden.
      if (!empty($value->hide)) {

        $remove[$key] = $key;
      }
    }

    // Remove hidden results from the view.
    foreach ($view->result as $key => $value) {
      // TODO: Get the properly the alias of iid.
      if (in_array($value->iid, $remove)) {
        unset($view->result[$key]);

        // Unset the key from the remove list, to make next checks a bit faster.
        unset($remove[$key]);
      }
      if (empty($remove)) {
        break;
      }
    }
  }
}

/**
 * Implementation of hook_ctools_plugin_*.
 *
 * Give information to CTools about the message plugin.
 */
function message_ctools_plugin_plugins() {
  return array(
    'process' => 'message_message_process',
  );
}

/**
 * Provide defaults for a message plugin.
 */
function message_message_process(&$plugin, $info) {
  $plugin += array(
    'realm' => FALSE,
    'title' => $plugin['name'],
    'description' => '',

    'views' => array(
      // Optional callback for views handlers.
      'handlers callback' => function_exists("$plugin[name]_views_handlers") ? "$plugin[name]_views_handlers" : FALSE,

      // Optional callback for views data.
      'data callback' => function_exists("$plugin[name]_views_data") ? "$plugin[name]_views_data" : FALSE,
    ),
    'access' => array(
      'access callback' => function_exists("$plugin[name]_access") ? "$plugin[name]_access" : 'message_plugin_access',
      'accessible ids callback' => function_exists("$plugin[name]_accessible_ids") ? "$plugin[name]_accessible_ids" : 'message_plugin_accessible_ids',
    ),
  );
}

/**
 * Implementation of hook_nodeapi().
 */
function message_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  // Advanced implementation may want to disable the cleanup and do it
  // themselves.
  if (!variable_get('message_entity_delete_cleanup', TRUE)) {
    return;
  }
  // Preform basic clean up when a node is deleted.
  if ($op == 'delete') {
    message_deleted_entity_cleanup('node', $node->nid);
  }
}

/**
 * Implementation of hook_comment().
 */
function message_comment(&$a1, $op) {
  // Advanced implementation may want to disable the cleanup and do it
  // themselves.
  if (!variable_get('message_entity_delete_cleanup', TRUE)) {
    return;
  }
  // Preform basic clean up when a comment is deleted.
  if ($op == 'delete') {
  }
}

/**
 * Implementation of hook_user().
 */
function message_user($op, &$edit, &$account, $category = NULL) {
  // Advanced implementation may want to disable the cleanup and do it
  // themselves.
  if (!variable_get('message_entity_delete_cleanup', TRUE)) {
    return;
  }
  if ($op == 'delete') {
    // Preform basic clean up when a user is deleted.
    message_deleted_entity_cleanup('user', $account->uid);
  }
}

/**
 * Implements hook_entity_info().
 */
function message_entity_info() {
  $items['message_type'] = array(
    'label' => t('Message type'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'MessageType',
    'base table' => 'message_type',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'name' => 'name',
      'label' => 'description',
    ),
    'exportable' => TRUE,
    'bundle of' => 'message',
  );
  $items['message'] = array(
    'label' => t('Message'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'Message',
    'base table' => 'message',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'mid',
      // The message has no label.
      'label' => FALSE,
      'bundle' => 'type',
    ),
    'bundle keys' => array(
      'bundle' => 'name',
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full'),
      ),
    ),
  );
  return $items;
}

/**
 * Implements hook_entity_info_alter().
 *
 * Prevent recursion in message_entity_info(), by adding the bundles here.
 */
function message_entity_info_alter(&$entity_info) {
  $types = entity_load('message_type');
  foreach ($types as $type_name => $type) {
    $entity_info['message']['bundles'][$type_name] = array(
    //@todo do we need a short label too?
      'label' => $type->name,
      'admin' => array(
        'path' => 'admin/structure/messages/manage/%message_type',
        'real path' => 'admin/structure/messages/manage/' . str_replace('_', '-', $type_name),
        'bundle argument' => 4,
        'access arguments' => array('administer messages'),
      ),
    );
  }
}

/**
 * API function; Save a message instance and save it to realms.
 *
 * @param $message_name
 *   The message name.
 * @param $entity_type
 *   The entity type.
 * @param $etid
 *   The entity ID.
 * @param $arguments
 *   Optional; Array of arguments to pass to the callback function.
 * @param $realms
 *   Optioanl; An array of arrays keyed with the realm ID. If no realms are
 *   provided then a the message instance will be assigned by default to the
 *   user realm, with the user ID as the realm ID.
 * @param $account
 *   Optional; The user object, if empty the logged in user will be used.
 * @param $extra_identifier
 *   Optioanl; The string value to save as the extra identfier.
 */
function message_save_message($message_name, $entity_type, $eid, $arguments = array(), $realms = array(), $account = NULL, $extra_identifier = '') {
  if (empty($account)) {
    global $user;
    $account = clone($user);
  }

  $return = array();

  // Create message instance.
  $message_instance = new stdClass();
  $message_instance->name = $message_name;
  $message_instance->uid = $account->uid;
  $message_instance->entity_type = $entity_type;
  $message_instance->eid = $eid;
  $message_instance->arguments = $arguments;
  $message_instance->extra_identifier = $extra_identifier;

  $message_instance = message_instance_save($message_instance);

  $return['message instance'] = $message_instance;

  if (empty($realms)) {
    // Set default realm.
    $realms[] = array('realm' => 'user', 'realm id' => $account->uid);
  }

  // Save to the realms.
  foreach ($realms as $value) {
    $realm = new stdClass();
    $realm->iid = $message_instance->iid;
    $realm->realm = $value['realm'];
    $realm->realm_id = $value['realm id'];
    $return['message realm'][] = message_realm_save($realm);
  }

  return $return;
}

/**
 * Field settings
 */

/**
 * Implements hook_field_info().
 */
function message_field_info() {
  return array(
    'message_realm' => array(
      'label' => t('Message realm'),
      'description' => t('This field stores realms associated with the message.'),
      'default_widget' => 'message_realm_widget',
      'default_formatter' => 'message_realm_formatter',
    ),
  );
}

/**
 * Implement hook_field_schema().
 */
function message_field_schema($field) {
  $columns = array(
    'mid' => array(
      'description' => 'The message ID.',
      'type' => 'float',
      'unsigned' => TRUE,
      'not null' => TRUE,
    ),
    'realm' => array(
      'description' => 'The realm this message belongs to.',
      'type' => 'varchar',
      'length' => 255,
      'not null' => TRUE,
      'default' => '',
    ),
    'realm_id' => array(
      'description' => 'The unique ID of the realm.',
      'type' => 'varchar',
      'length' => 255,
      'not null' => TRUE,
      'default' => '',
    ),
  );
  return array(
    'columns' => $columns,
    'indexes' => array(
      'mid' => array('mid'),
    ),
  );
}

/**
 * Implements hook_field_formatter_info().
 */
function message_field_formatter_info() {
  return array(
    'message_realm_formatter' => array(
      'label' => t('Message realm'),
      'field types' => array('message_realm'),
    ),
  );
}


/**
 * Implements hook_element_info().
 */
function message_element_info() {
  $types = array();
  $types['message_realm'] = array(
    '#input' => TRUE,
    '#multiple' => TRUE,
    '#process' => array('form_process_select', 'messge_process_message_realm'),
    '#theme_wrappers' => array('form_element'),
  );

  return $types;
}

/**
 * Process the "message_realm" form element.
 *
 * Expands the element into a select list with the realm types, and a text field
 * text accepts the realm ID.
 */
function messge_process_message_realm($element) {
  $options = message_get_realm_types();
  $element['realm'] =  array(
    '#type' => 'select',
    '#title' => t('Realm'),
    '#options' => $options,
    // FIXME:
    '#default_value' => array(),
    '#required' => TRUE,
    '#attributes' => array('class' => array('message-realm')),
  );

  $element['realm_id'] =  array(
    '#type' => 'textfield',
    '#title' => t('Realm ID'),
    // FIXME:
    '#default_value' => '',
    '#required' => TRUE,
    '#attributes' => array('class' => array('message-realm-id')),
  );

  return $element;
}

/**
 * Implements hook_field_widget_form().
 */
function message_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $base) {
  $element = $base;
  $widget = $instance['widget'];

  switch ($widget['type']) {
    case 'message_realm':
    break;
  }

  return $element;
}

/**
 * Load & crud functions ==============================================
 */


/**
 * Use a separate class for message types so we can specify some defaults
 * modules may alter.
 */
class MessageType extends EntityDB {
  public $type;
  public $description = '';

  public function __construct($values = array()) {
    parent::__construct($values, 'message_type');
  }
}

/**
 * Wrapper to create a message type stub.
 */
function message_type_create($name, $values = array()) {
  $values['name'] = $name;
  return new MessageType($values);
}

/**
 * Message type loader.
 *
 * @param $type_name
 *   The name for this message type.
 *
 * @return MessageType
 *   Returns a fully-loaded message definition.
 */
function message_type_load($type_name = '') {
  // Replace dashes with underscores so this can be used as menu argument
  // loader too.
  $types = entity_load('message_type', isset($type_name) ? array(strtr($type_name, array('-' => '_'))) : FALSE);
  if (isset($type_name)) {
    return isset($types[$type_name]) ? $types[$type_name] : FALSE;
  }
  return $types;
}


/**
 * Inserts or updates a message object into the database.
 *
 * @param $message
 *   The message object to be inserted.
 *
 * @return
 *   Failure to write a record will return FALSE. Otherwise SAVED_NEW or
 *   SAVED_UPDATED is returned depending on the operation performed.
 */
function message_type_save($message) {
  return entity_save('message_type', $message);
}

/**
 * Deletes an existing message.
 *
 * @param $message
 *   The message object to be deleted.
 */
function message_type_delete($message) {
  return entity_delete('message_type', $message);
}


/**
 * Use a separate class for message types so we can specify some defaults
 * modules may alter.
 */
class Message extends EntityDB {

  public $name;
  public $arguments = array();
  public $timestamp;

  public function __construct($values = array()) {
    $values += array('uid' => $GLOBALS['user']->uid, 'timestamp' => time());
    parent::__construct($values, 'message');
  }
}

/**
 * Wrapper to create a message stub.
 */
function message_create($name, $values = array(), $account = NULL) {
  $values['name'] = $name;
  if (empty($values['uid']) && $account) {
    $values['uid'] = $account->uid;
  }
  return new Message($values);
}

/**
 * Message load.
 *
 * @param $mid
 *   The message ID.
 * @return Message
 *   A message object.
 */
function message_load($mid) {
  $result = entity_load('message', array($mid));
  return $result ? reset($result) : FALSE;
}

/**
 * Message save.
 *
 * @param $message_instance
 *   A message instance object.
 * @return
 *   The saved message instance object.
 */
function message_save($message) {
  return entity_save('message', $message);
}

/**
 * Message delete.
 *
 * @param $iid
 *   Message instance IDs array.
 */
function message_delete_multiple($mids = array()) {
  entity_delete_multiple('message', $mids);
}

/**
 * Get realm messages by their ID.
 *
 * @param $message_id
 *   The message ID.
 * @return
 *   Array keyed by the message realm and the realm Id as the value.
 */
function message_realm_load_multiple_by_message($message_id) {
  static $messages = array();

  if (!isset($messages[$message_id])) {
    $result = db_query("SELECT * FROM {message_realm} WHERE iid = %d", $message_id);

    while ($row = db_fetch_object($result)) {
      $messages[$message_id][$row->realm][$row->realm_id] = $row->realm_id;
    }
  }
  return !empty($messages[$message_id]) ? $messages[$message_id] : array() ;
}

/**
 * Message realm load.
 *
 * @param $iid
 * @return unknown_type
 */
function message_realm_load($rid) {
  return db_fetch_object(db_query("SELECT * FROM {message_realm} where rid = %d", $rid));
}

/**
 * Message realm save.
 *
 * @param $message_instance
 *
 * @return
 *   The message realm object.
 */
function message_realm_save($message_realm) {
  if ($existing = message_realm_load($message_realm->rid)) {
    drupal_write_record('message_realm', $message_realm, 'rid');
  }
  else {
    drupal_write_record('message_realm', $message_realm);
  }
  return $message_realm;
}

/**
 * Message realm delete.
 *
 * @param $rid
 *   Message realm IDs array.
 */
function message_realm_delete($rids = array()) {
  $placeholders = db_placeholders($rids);

  db_query("DELETE FROM {message_realm} WHERE rid IN ($placeholders)", explode(',', $rids));
}

/**
 * Message realm delete by message instance ID.
 *
 * @param $iids
 *   Message instance IDs array.
 */
function message_realm_delete_by_message_instance($iids = array()) {
  $placeholders = db_placeholders($iids);

  db_query("DELETE FROM {message_realm} WHERE iid IN ($placeholders)", implode(',', $iids));
}

/**
 * Message realm delete by realm type and realm ID.
 *
 * @param $realm
 *   The realm name.
 * @param $realm_id
 *   The realm ID.
 */
function message_realm_delete_by_realm($realm, $realm_id) {
  db_query("DELETE FROM {message_realm} WHERE realm = '%s' AND eid = '%s'", $realm, $realm_id);
}


function message_get_plugin_message($plugin_name) {
  ctools_include('plugins');
  return ctools_get_plugins('message', 'plugins', $plugin_name);
}

function message_get_plugin_messages() {
  ctools_include('plugins');
  return ctools_get_plugins('message', 'plugins');
}

/**
 * Show a message by the message instance ID.
 *
 * @param $message_instance
 *   The message instance object.
 * @param $account
 *   Optional; The account that access should be checked for.
 *
 * @return
 *   HTML with the message.
 */
function message_show_message($message_instance, $skip_access = FALSE, $account = NULL) {
  $output = '';
  $access = FALSE;
  if (empty($account)) {
    global $user;
    $account = clone($user);
  }

  if ($skip_access) {
    $access = TRUE;
  }
  elseif ($realms = message_realm_load_multiple_by_message($message_instance->iid)) {
    foreach (message_get_plugin_messages() as $plugin) {
      if (in_array($plugin['realm'], array_keys($realms)) && message_show_message_access($plugin, $message_instance, $realms[$plugin['realm']])) {
        $access = TRUE;
        break;
      }
    }
  }

  if ($access) {
    $output = theme('message', array('message' => $message_instance, 'output' => message_t($message_instance)));
  }

  return $output;
}

function message_show_message_access($plugin, $message_instance, $realm_ids = array(), $account = NULL) {
  $return = FALSE;

  if (!empty($plugin['realm'])) {
    if (empty($realm_ids)) {
      $realms = message_realm_load_multiple_by_message($message_instance->iid);
      $realm_ids = !empty($realms[$plugin['realm']]) ? $realms[$plugin['realm']] : array();
    }

    if ($realm_ids) {
      if (empty($account)) {
        global $user;
        $account = clone($user);
      }
      $return = call_user_func($plugin['access']['access callback'], $plugin, $message_instance, $realm_ids, $account);
    }
  }
  return $return;
}

function message_get_accessiable_ids_by($plugin, $account = NULL) {
  if (empty($account)) {
    global $user;
    $account = clone($user);
  }
  return call_user_func($plugin['access']['accessible ids callback'], $account);
}

/**
 * Replace arguments with their placeholders.
 *
 * @param $message
 *   The message instance object.
 *
 * @see t().
 */
function message_t($message_instance) {
  if (!empty($message_instance->hide)) {
    return '';
  }

  $string = message_get_string_i18n($message_instance);

  if (empty($message_instance->arguments)) {
    return $string;
  }
  else {
    // Transform arguments before inserting them.
    foreach ($message_instance->arguments as $key => $value) {

      if (is_array($value) && !empty($value['callback']) && function_exists($value['callback'])) {
        // A replacement via callback function.
        $value = call_user_func_array($value['callback'], $value['callback arguments']);
      }

      switch ($key[0]) {
        case '@':
          // Escaped only.
          $args[$key] = check_plain($value);
          break;

        case '%':
        default:
          // Escaped and placeholder.
          $args[$key] = theme('placeholder', $value);
          break;

        case '!':
          // Pass-through.
          $args[$key] = $value;
      }
    }
    return strtr($string, $args);
  }
}

/**
 * Get the string of the message.
 *
 * @param $message
 *   The message object,
 *
 * @return
 *   This function checkes if the i18n module is enabled and provides the
 *   translated string if needed. It also checkes if the message was overriden
 *   and if so, return the overriden string.
 */
function message_get_string_i18n($message_instance) {
  $message = message_load($message_instance->name);

  if (!empty($message_instance->override)) {
    $name_property = $message_instance->override_name;
    $message_property = $message_instance->message;
  }
  else {
    $name_property = $message->name;
    $message_property = $message->message;
  }

  if (module_exists(i18nstrings)) {
    // Get the translation of the original or overriden message.
    $string = i18nstrings('messages:message:' . $name_property .':message', $message_property);
  }
  else {
    $string = $message_property;
  }

  return $string;
}

/**
 * Override the message, and if i18n module is enabled, register the string.
 *
 * @param $message
 *   The message object passed by reference.
 * @param $override_name
 *   The name of the overriden message, to be appended to the original name.
 * @param $override_message
 *   The overriden message.
 */
function message_override_message_instance(&$message_instance, $override_name, $override_message) {
  $message = message_load($message_instance->name);
  $message_instance->override_name = $message->name . '_' . $override_name;
  $message_instance->message = $override_message;
  // Set a flag.
  $message_instance->override = TRUE;

  if (module_exists('i18nstrings')) {
    // Register the string.
    $cache = cache_get('message_i18nstrings');

    $i18nstrings = array();

    if (!empty($cache->data)) {
      $i18nstrings = $cache->data;
    }

    $set = FALSE;
    if (empty($i18nstrings[$message_instance->override_name])) {
      // Create string.
      i18nstrings_update("messages:message:$message_instance->name:message", $message_instance->message);
      $i18nstrings[$message_instance->override_name] = TRUE;
      $set = TRUE;
    }

    if ($set) {
      // Cache all the strings that were translated.
      cache_set('message_i18nstrings', $i18nstrings);
    }
  }
}

/**
 * Theme the message.
 */
function theme_message($message = array()) {
  return '<span class="message message-instance-'. $message['message']->iid .'">'. $message['output'] .'</span>';
}

/**
 * Return an array of realms keyed by the plugin name and the realm value.
 */
function message_get_realm_types() {
  $options = &drupal_static(__FUNCTION__, array());
  if (empty($options)) {
    foreach (message_get_plugin_messages() as $plugin) {
      if (!empty($plugin['realm'])) {
        $options[$plugin['name']] = check_plain($plugin['title']);
      }
    }
  }

  return $options;
}

/**
 * Delete message instances that are related to a a deleted entity.
 *
 * For example, if a node is deleted then all the message instances that are
 * related to that node will be deleted.
 *
 * @param $entity_type
 *   The entity type.
 * @param $eid
 *   The entity ID.
 */
function message_deleted_entity_cleanup($entity_type, $eid) {
  // Get all the message instanced.
  $result = db_query("SELECT iid FROM {message_instance} WHERE entity_type = '%s' AND eid = %d", $entity_type, $eid);

  $iids = array();
  while ($row = db_fetch_object($result)) {
    $iids[] = $row->iid;
  }

  // Instances were found and need to be deleted.
  if ($iids) {
    message_instance_delete($iids);
    message_realm_delete($entity_type, $eid);
  }
}