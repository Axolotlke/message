<?php
// $Id: message.module,v 1.12 2010/06/07 10:54:11 amitaibu Exp $

/**
 * @file
 * API functions to manipulate messages.
 */

/**
 * Minimum CTools version needed.
 */
define('MESSAGE_REQUIRED_CTOOLS_API', '2.0-alpha1');

/**
 * Define the name of the message realm field.
 */
define('MESSAGE_FIELD_REALM', 'message_realm');


/**
 * Define the name of the message realm field.
 */
define('MESSAGE_FIELD_MESSAGE_TYPE_TEXT', 'message_type_text');


/**
 * Implementation of hook_ctools_plugin_api().
 */
function message_ctools_plugin_api($module, $api) {
  if ($module == 'message' && $api == 'plugins') {
    return array('version' => 1);
  }
}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function message_ctools_plugin_directory($module, $type) {
  // Safety: go away if CTools is not at an appropriate version.
  if (!module_invoke('ctools', 'api_version', MESSAGE_REQUIRED_CTOOLS_API)) {
    return;
  }
  if ($module =='message' && $type == 'message') {
    return 'plugins/message';
  }
  elseif ($type =='export_ui') {
    return 'plugins/export_ui';
  }
}

/**
 * Implementation of hook_views_api().
 */
function message_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'message') . '/includes',
  );
}

/**
 * Implementation of hook_features_api().
 */
function message_features_api() {
  return array(
    'message' => array(
      'name' => 'Messages',
      'api' => 'message',
      'default_hook' => 'message_default_messages',
      'current_version' => 1,
      'module' => 'message',
      'feature_source' => TRUE,
    ),
  );
}

/**
 * Implementation of hook_theme().
 */
function message_theme() {
  // Safety: go away if CTools is not at an appropriate version.
  if (!module_invoke('ctools', 'api_version', MESSAGE_REQUIRED_CTOOLS_API)) {
    return;
  }

  $items = array();
  $items['message'] = array(
    'arguments' => array(
      'render element' => 'elements',
    ),
  );
  return $items;
}

/**
 * Implements hook_ctools_plugin_type()
 *
 * Inform the plugin system that Message modules owns message, export-ui
 * plugins.
 */
function message_ctools_plugin_type() {
  $items = array();

  $items['message'] = array(
    'process' => array(
      'function' => 'message_message_process',
      'file' => 'message_plugin.inc',
      'path' => drupal_get_path('module', 'message') . '/plugins/message',
    ),
    'classes' => array('handler'),
  );

  $items['export_ui'] = array();

  return $items;
}

/**
 * Implementation of hook_views_pre_render().
 *
 * In order to reduce the database hits, we take advantage of the fact that we
 * know the message instances IDs before they are rendered. We load them all,
 * and they are saved in a static cache. So later when they are rendered, the
 * message instances are already cached.
 *
 * @see message_instance_load_multiple().
 * @see message_show_message().
 */
function message_views_pre_render(&$view) {
  // Define if this is a view that involves message instance, and thus should be
  // processed.
  $process = FALSE;
  $ids = array();
  // Look for a field that belong to the {message_instance} table.
  foreach ($view->field as $field) {
    if ($field->definition['handler'] == 'message_handler_field_message_render') {
      $field_alias = $field->field_alias;
      $process = TRUE;
      break;
    }
  }
  if ($process && !empty($view->result)) {
    foreach ($view->result as &$row) {
      $ids[] = $row->{$field_alias};
    }
  }

  // Load the message instances, so they will be statically cached.
  if ($ids && $message_instances = message_instance_load_multiple($ids)) {
    $remove = array();
    foreach ($message_instances as $key => $value) {
      // Check if messages should be hidden.
      if (!empty($value->hide)) {

        $remove[$key] = $key;
      }
    }

    // Remove hidden results from the view.
    foreach ($view->result as $key => $value) {
      // TODO: Get the properly the alias of iid.
      if (in_array($value->iid, $remove)) {
        unset($view->result[$key]);

        // Unset the key from the remove list, to make next checks a bit faster.
        unset($remove[$key]);
      }
      if (empty($remove)) {
        break;
      }
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function message_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  // Advanced implementation may want to disable the cleanup and do it
  // themselves.
  if (!variable_get('message_entity_delete_cleanup', TRUE)) {
    return;
  }
  // Preform basic clean up when a node is deleted.
  if ($op == 'delete') {
    message_deleted_entity_cleanup('node', $node->nid);
  }
}

/**
 * Implementation of hook_comment().
 */
function message_comment(&$a1, $op) {
  // Advanced implementation may want to disable the cleanup and do it
  // themselves.
  if (!variable_get('message_entity_delete_cleanup', TRUE)) {
    return;
  }
  // Preform basic clean up when a comment is deleted.
  if ($op == 'delete') {
  }
}

/**
 * Implementation of hook_user().
 */
function message_user($op, &$edit, &$account, $category = NULL) {
  // Advanced implementation may want to disable the cleanup and do it
  // themselves.
  if (!variable_get('message_entity_delete_cleanup', TRUE)) {
    return;
  }
  if ($op == 'delete') {
    // Preform basic clean up when a user is deleted.
    message_deleted_entity_cleanup('user', $account->uid);
  }
}

/**
 * Implements hook_entity_info().
 */
function message_entity_info() {
  $items['message_type'] = array(
    'label' => t('Message type'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'MessageType',
    'base table' => 'message_type',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'label' => 'name',
      'name' => 'name',
    ),
    'exportable' => TRUE,
    'bundle of' => 'message',
  );
  $items['message'] = array(
    'label' => t('Message'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'Message',
    'base table' => 'message',
    'fieldable' => TRUE,
    'access callback' => 'message_access',
    'entity keys' => array(
      'id' => 'mid',
      // The message has no label.
      'label' => FALSE,
      'bundle' => 'name',
    ),
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => 'name',
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full'),
      ),
    ),
  );
  return $items;
}

/**
 * Implements hook_entity_info_alter().
 *
 * Use this hook to specify bundles to avoid a recursion, as loading the entity
 * message types needs the entity info too.
 */
function message_entity_info_alter(&$entity_info) {
  $message_types = entity_load('message_type');
  foreach ($message_types as $type_name => $type) {
    $entity_info['message']['bundles'][$type_name] = array(
      //@todo do we need a short label too?
      'label' => $type->name,
      'admin' => array(
        'path' => 'admin/structure/messages/manage/%message_type',
        'real path' => 'admin/structure/messages/manage/' . str_replace('_', '-', $type->name),
        'bundle argument' => 4,
        'access arguments' => array('administer messages'),
      ),
    );
  }
}

/**
 * Add message realm field to a message bundle.
 */
function message_add_field_message_realm($bundle) {
  $entity_type = 'message';
  $field_name = MESSAGE_FIELD_REALM;
  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle);

  if (empty($field)) {
    $field = array(
      'field_name' => $field_name,
      'type' => $field_name,
      'entity_types' => array($entity_type),
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
    );
    $field = field_create_field($field);
  }

  if (empty($instance)) {
    $instance = array(
      'field_name' => $field_name,
      'bundle' => $bundle,
      'entity_type' => $entity_type,
    );

    field_create_instance($instance);
  }
}

/**
 * Add message realm field to a message bundle.
 */
function message_add_field_message_type_text($bundle) {
  $entity_type = 'message_type';
  $field_name = MESSAGE_FIELD_MESSAGE_TYPE_TEXT;
  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle);

  if (empty($field)) {
    $field = array(
      'field_name' => $field_name,
      'type' => 'text_long',
      'entity_types' => array($entity_type),
      'translatable' => TRUE,
    );
    $field = field_create_field($field);
  }

  if (empty($instance)) {
    $instance = array(
      'field_name' => $field_name,
      'bundle' => $bundle,
      'entity_type' => $entity_type,
      'settings' => array(),
      'description' => t('The message type text'),
    );

    field_create_instance($instance);
  }
}

/**
 * API function; Save a message.
 *
 * @param $message_name
 *   The message name.
 * @param $entity_type
 *   The entity type.
 * @param $etid
 *   The entity ID.
 * @param $arguments
 *   Optional; Array of arguments to pass to the callback function.
 * @param $realms
 *   Optioanl; An array of arrays keyed with the realm ID. If no realms are
 *   provided then a the message instance will be assigned by default to the
 *   user realm, with the user ID as the realm ID.
 * @param $account
 *   Optional; The user object, if empty the logged in user will be used.
 * @param $extra_identifier
 *   Optioanl; The string value to save as the extra identfier.
 */
function message_save_message($message_name, $entity_type, $eid, $arguments = array(), $realms = array(), $account = NULL, $extra_identifier = '') {
  $message = message_create($name, $values, $account);
  $message->save();
  return $message;
}

/**
 * Field settings
 */

/**
 * Implements hook_field_info().
 */
function message_field_info() {
  return array(
    MESSAGE_FIELD_REALM => array(
      'label' => t('Message realm'),
      'description' => t('This field stores realms associated with the message.'),
      'default_widget' => MESSAGE_FIELD_REALM,
      'default_formatter' => 'message_realm_formatter',
    ),
  );
}

/**
 * Implement hook_field_schema().
 */
function message_field_schema($field) {
  $columns = array(
    'realm' => array(
      'description' => 'The realm this message belongs to.',
      'type' => 'varchar',
      'length' => 255,
      'not null' => TRUE,
      'default' => '',
    ),
    'realm_id' => array(
      'description' => 'The unique ID of the realm.',
      'type' => 'varchar',
      'length' => 255,
      'not null' => TRUE,
      'default' => '',
    ),
  );
  return array(
    'columns' => $columns,
    'indexes' => array(
      'mid' => array('realm', 'realm_id'),
    ),
  );
}

/**
 * Implements hook_field_formatter_info().
 */
function message_field_formatter_info() {
  return array(
    'message_realm_formatter' => array(
      'label' => t('Message realm'),
      'field types' => array('message_realm'),
    ),
  );
}

/**
 * Implement hook_field_widget_info().
 */
function message_field_widget_info() {
  return array(
    MESSAGE_FIELD_REALM => array(
      'label' => t('Message realm'),
      'field types' => array(MESSAGE_FIELD_REALM),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
      'settings' => array(),
    ),
  );
}

/**
 * Implement hook_field_widget_form().
 */
function message_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $base) {
  $element = $base;
  $widget = $instance['widget'];

  if ($widget['type'] == MESSAGE_FIELD_REALM) {
    $element += array(
      // Input should be TRUE only if there are groups that can be selected.
      '#type' => 'message_realm',
    );
  }

  return $element;
}

/**
 * Implement hook_field_is_empty().
 */
function message_field_is_empty($item, $field) {
  return empty($item['mid']);
}


/**
 * Implements hook_element_info().
 */
function message_element_info() {
  $types = array();
  $types['message_realm'] = array(
    '#input' => TRUE,
    '#multiple' => TRUE,
    '#process' => array('form_process_select', 'messge_process_message_realm'),
    '#theme_wrappers' => array('form_element'),
  );

  return $types;
}

/**
 * Process the "message_realm" form element.
 *
 * Expands the element into a select list with the realm types, and a text field
 * text accepts the realm ID.
 */
function messge_process_message_realm($element) {
  $options = message_get_realm_types();
  $element['realm'] =  array(
    '#type' => 'select',
    '#title' => t('Realm'),
    '#options' => $options,
    // FIXME:
    '#default_value' => array(),
    '#required' => TRUE,
    '#attributes' => array('class' => array('message-realm')),
  );

  $element['realm_id'] =  array(
    '#type' => 'textfield',
    '#title' => t('Realm ID'),
    // FIXME:
    '#default_value' => '',
    '#required' => TRUE,
    '#attributes' => array('class' => array('message-realm-id')),
  );

  return $element;
}

/**
 * Load & crud functions ==============================================
 */


/**
 * Use a separate class for message types so we can specify some defaults
 * modules may alter.
 */
class MessageType extends EntityDB {
  public $name;
  public $description = '';

  public function __construct($values = array()) {
    parent::__construct($values, 'message_type');
  }
}

/**
 * Wrapper to create a message type stub.
 */
function message_type_create($name, $values = array(), $save = TRUE) {
  global $language;
  $values['name'] = $name;

  if (empty($values['text'])) {
    // Set default text if none was specified.
    $values['text'][$language->language] = '';
  }

  if (!empty($values['text'])) {
    // Prepare the realms to be passed inside the field.
    foreach ($values['text'] as $lang => $text) {
      $values[MESSAGE_FIELD_MESSAGE_TYPE_TEXT][$lang][0]['value'] = $text;
    }
  }

  $message_type = new MessageType($values);
  if ($save) {
    $message_type->save();
    // FIXME: Find the right place for this.
    // hook_message_type_insert() runs only after hook_entity_info_alter()
    // where the bundles are inserted.
    // Add the message realm field to the new bundle.
    message_add_field_message_realm($message_type->name);

    // Add the message-type-text as a field to the message type entity.
    message_add_field_message_type_text($message_type->name);

    // FIXME: Only after we save the bundle, we can add it the message type text
    // field, and then we populate it with the values. So we need to save it
    // twice - This of course seems very wrong, but it's a workaround.
    $message_type = message_type_load($message_type->name);

    $property = MESSAGE_FIELD_MESSAGE_TYPE_TEXT;
    foreach ($values['text'] as $lang => $text) {
      $message_type->{$property}[$lang][0]['value'] = $text;
    }

    $message_type->save();
  }

  return $message_type;
}

/**
 * Message type loader.
 *
 * @param $type_name
 *   The name for this message type.
 *
 * @return MessageType
 *   Returns a fully-loaded message type definition.
 */
function message_type_load($name = '') {
  // Replace dashes with underscores so this can be used as menu argument
  // loader too.
  $types = entity_load('message_type', isset($name) ? array(strtr($name, array('-' => '_'))) : FALSE);
  if (isset($name)) {
    return isset($types[$name]) ? $types[$name] : FALSE;
  }
  return $types;
}


/**
 * Inserts or updates a message object into the database.
 *
 * @param $message
 *   The message object to be inserted.
 *
 * @return
 *   Failure to write a record will return FALSE. Otherwise SAVED_NEW or
 *   SAVED_UPDATED is returned depending on the operation performed.
 */
function message_type_save($message) {
  return entity_save('message_type', $message);
}

/**
 * Deletes an existing message.
 *
 * @param $message
 *   The message object to be deleted.
 */
function message_type_delete($message) {
  return entity_delete('message_type', $message);
}


/**
 * Use a separate class for message types so we can specify some defaults
 * modules may alter.
 */
class Message extends EntityDB {
  public $name;
  public $arguments = array();
  public $timestamp;

  public function __construct($values = array()) {
    $values += array('uid' => $GLOBALS['user']->uid, 'timestamp' => time());
    parent::__construct($values, 'message');
  }
}

/**
 * Wrapper to create a message stub.
 *
 * TODO: Document values.
 */
function message_create($name, $values = array(), $save = TRUE, $account = NULL) {
  global $user;
  $values['name'] = $name;
  if (empty($values['uid'])) {
    $values['uid'] = !empty($account) ? $account->uid : $user->uid;
  }

  if (empty($values['realm'])) {
    // Set default realm if realm wasn't specified.
    $values['realm'][] = array(
      'realm' => 'user',
      'realm_id' => $values['uid'],
    );
  }

  if (!empty($values['realm'])) {
    // Prepare the realms to be passed inside the field.
    foreach ($values['realm'] as $value) {
      $values[MESSAGE_FIELD_REALM][LANGUAGE_NONE][] = array(
        'realm' => $value['realm'],
        'realm_id' => $value['realm_id'],
      );
    }
  }

  // Remove the helper values.
  unset ($values['realm']);

  $return = new Message($values);

  if ($save) {
    $return->save();
  }

  return $return;
}

/**
 * Message load.
 *
 * @param $mid
 *   The message ID.
 * @return Message
 *   A message object.
 */
function message_load($mid) {
  $result = entity_load('message', array($mid));
  return $result ? reset($result) : FALSE;
}

/**
 * Message save.
 *
 * @param $message_instance
 *   A message instance object.
 * @return
 *   The saved message instance object.
 */
function message_save($message) {
  return entity_save('message', $message);
}

/**
 * Message delete.
 *
 * @param $iid
 *   Message instance IDs array.
 */
function message_delete_multiple($mids = array()) {
  entity_delete_multiple('message', $mids);
}

/**
 * Access callback for the message entity.
 */
function message_access($op, $entity, $account = NULL, $entity_type = 'message') {
  global $user;
  $access = FALSE;
  if ($op == 'view') {
    if (empty($account)) {
      $account = clone $user;
    }

    $property = MESSAGE_FIELD_REALM;
    if (!empty($entity->{$property}[LANGUAGE_NONE])) {
      $plugins = message_get_plugin_messages();

      // Map the realm to the plugin.
      // TODO: Maybe the realm name should be the plugin name?
      $realm_plugin = array();
      foreach ($plugins as $plugin_name => $plugin) {
        if (!empty($plugin['realm'])) {
          $realm_plugin[$plugin['realm']] = $plugin_name;
        }
      }

      // Get all the realms IDs keyed by the message realm, to save multiple
      // calls to access check.
      $realms = array();
      foreach ($entity->{$property}[LANGUAGE_NONE] as $row) {
        $realms[$row['realm']][]= $row['realm_id'];
      }

      foreach ($realms as $realm => $realm_ids) {
        $accessibale_ids = call_user_func($plugins[$realm_plugin[$realm]]['access']['accessible ids callback'], $account);
        if (array_intersect($accessibale_ids, $realm_ids)) {
          $access = TRUE;
          break;
        }
      }
    }
    else {
      // No realms, so access is allowed.
      $access = TRUE;
    }
  }

  return $access;
}

function message_get_plugin_message($plugin_name) {
  ctools_include('plugins');
  return ctools_get_plugins('message', 'message', $plugin_name);
}

function message_get_plugin_messages() {
  ctools_include('plugins');
  return ctools_get_plugins('message', 'message');
}

/**
 * Show a message by the message instance ID.
 *
 * @param $message_instance
 *   The message instance object.
 * @param $skip_access
 *   Determine if access should be checked for the user. Defautls to FALSE, as
 *   access check is probably going to happen through the Views' filter system.
 * @param $account
 *   Optional; The account that access should be checked for. Defaults to the
 *   current user.
 * @param $lang
 *   Optional; The language the message should return in. Defaults to the
 *   current language.
 *
 * @return
 *   HTML with the message.
 */
function message_show_message($message, $skip_access = FALSE, $account = NULL, $lang = '') {
  $output = '';
  $access = FALSE;
  if (empty($account)) {
    global $user;
    $account = clone($user);
  }

  $access = $skip_access ? TRUE : message_access('view', $message, $account);

  if ($access) {
    $output = theme('message', array('message' => $message, 'output' => message_t($message, $lang)));
  }

  return $output;
}



function message_get_accessiable_realm_ids_by_plugin($plugin, $account = NULL) {
  if (empty($account)) {
    global $user;
    $account = clone($user);
  }
  return call_user_func($plugin['access']['accessible ids callback'], $account);
}

/**
 * Replace arguments with their placeholders.
 *
 * @param $message
 *   The message instance object.
 *
 * @param $language
 *   Optional; The language to get the text in. If not set the current language
 *   will be used.
 *
 * @see t().
 */
function message_t($message, $lang = '') {
  global $language;
  if (!empty($message->hide)) {
    return '';
  }

  if (empty($lang)) {
    $lang = $language->language;
  }

  $property = MESSAGE_FIELD_MESSAGE_TYPE_TEXT;
  // Get the message type.
  $message_type = message_type_load($message->name);

  $string = !empty($message_type->{$property}[$lang][0]['value']) ? $message_type->{$property}[$lang][0]['value'] : '';

  if (empty($message->arguments)) {
    return $string;
  }
  else {
    // Transform arguments before inserting them.
    foreach ($message->arguments as $key => $value) {

      if (is_array($value) && !empty($value['callback']) && function_exists($value['callback'])) {
        // A replacement via callback function.
        $value = call_user_func_array($value['callback'], $value['callback arguments']);
      }

      switch ($key[0]) {
        case '@':
          // Escaped only.
          $args[$key] = check_plain($value);
          break;

        case '%':
        default:
          // Escaped and placeholder.
          $args[$key] = theme('placeholder', $value);
          break;

        case '!':
          // Pass-through.
          $args[$key] = $value;
      }
    }
    return strtr($string, $args);
  }
}

/**
 * Get the string of the message.
 *
 * @param $message
 *   The message object,
 *
 * @return
 *   This function checkes if the i18n module is enabled and provides the
 *   translated string if needed. It also checkes if the message was overriden
 *   and if so, return the overriden string.
 */
function message_get_string_i18n($message_instance) {
  $message = message_load($message_instance->name);

  if (!empty($message_instance->override)) {
    $name_property = $message_instance->override_name;
    $message_property = $message_instance->message;
  }
  else {
    $name_property = $message->name;
    $message_property = $message->message;
  }

  if (module_exists(i18nstrings)) {
    // Get the translation of the original or overriden message.
    $string = i18nstrings('messages:message:' . $name_property .':message', $message_property);
  }
  else {
    $string = $message_property;
  }

  return $string;
}

/**
 * Override the message, and if i18n module is enabled, register the string.
 *
 * @param $message
 *   The message object passed by reference.
 * @param $override_name
 *   The name of the overriden message, to be appended to the original name.
 * @param $override_message
 *   The overriden message.
 */
function message_override_message_instance(&$message_instance, $override_name, $override_message) {
  $message = message_load($message_instance->name);
  $message_instance->override_name = $message->name . '_' . $override_name;
  $message_instance->message = $override_message;
  // Set a flag.
  $message_instance->override = TRUE;

  if (module_exists('i18nstrings')) {
    // Register the string.
    $cache = cache_get('message_i18nstrings');

    $i18nstrings = array();

    if (!empty($cache->data)) {
      $i18nstrings = $cache->data;
    }

    $set = FALSE;
    if (empty($i18nstrings[$message_instance->override_name])) {
      // Create string.
      i18nstrings_update("messages:message:$message_instance->name:message", $message_instance->message);
      $i18nstrings[$message_instance->override_name] = TRUE;
      $set = TRUE;
    }

    if ($set) {
      // Cache all the strings that were translated.
      cache_set('message_i18nstrings', $i18nstrings);
    }
  }
}

/**
 * Theme the message.
 */
function theme_message($variables = array()) {
  $message = $variables['message'];
  $output = $variables['output'];
  return '<span class="message-type-' . str_replace('_', '-', check_plain($message->name)) .' message-id-'. $message->mid .'">'. $output .'</span>';
}

/**
 * Return an array of realms keyed by the plugin name and the realm value.
 */
function message_get_realm_types() {
  $options = &drupal_static(__FUNCTION__, array());
  if (empty($options)) {
    foreach (message_get_plugin_messages() as $plugin) {
      if (!empty($plugin['realm'])) {
        $options[$plugin['name']] = check_plain($plugin['title']);
      }
    }
  }

  return $options;
}

/**
 * Delete message instances that are related to a a deleted entity.
 *
 * For example, if a node is deleted then all the message instances that are
 * related to that node will be deleted.
 *
 * @param $entity_type
 *   The entity type.
 * @param $eid
 *   The entity ID.
 */
function message_deleted_entity_cleanup($entity_type, $eid) {
  // Get all the message instanced.
  $result = db_query("SELECT iid FROM {message_instance} WHERE entity_type = '%s' AND eid = %d", $entity_type, $eid);

  $iids = array();
  while ($row = db_fetch_object($result)) {
    $iids[] = $row->iid;
  }

  // Instances were found and need to be deleted.
  if ($iids) {
    message_instance_delete($iids);
    message_realm_delete($entity_type, $eid);
  }
}