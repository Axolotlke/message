<?php
// $Id: message.module,v 1.12 2010/06/07 10:54:11 amitaibu Exp $

/**
 * @file
 * API functions to manipulate messages.
 */

/**
 * Minimum CTools version needed.
 */
define('MESSAGE_REQUIRED_CTOOLS_API', '2.0-alpha1');

/**
 * Define the name of the message realm field.
 */
define('MESSAGE_FIELD_MESSAGE_TEXT', 'message_text');


/**
 * Implementation of hook_ctools_plugin_api().
 */
function message_ctools_plugin_api($module, $api) {
  if ($module == 'message' && $api == 'plugins') {
    return array('version' => 1);
  }
}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function message_ctools_plugin_directory($module, $type) {
  // Safety: go away if CTools is not at an appropriate version.
  if (!module_invoke('ctools', 'api_version', MESSAGE_REQUIRED_CTOOLS_API)) {
    return;
  }
  if ($module =='message' && $type == 'message') {
    return 'plugins/message';
  }
}

/**
 * Implementation of hook_views_api().
 */
function message_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'message') . '/includes',
  );
}

/**
 * Implementation of hook_theme().
 */
function message_theme() {
  // Safety: go away if CTools is not at an appropriate version.
  if (!module_invoke('ctools', 'api_version', MESSAGE_REQUIRED_CTOOLS_API)) {
    return;
  }

  $items = array();
  $items['message'] = array(
    'arguments' => array(
      'render element' => 'elements',
    ),
  );
  return $items;
}

/**
 * Implements hook_ctools_plugin_type()
 *
 * Inform the plugin system that Message modules owns message, export-ui
 * plugins.
 */
function message_ctools_plugin_type() {
  $items = array();

  $items['message'] = array(
    'process' => array(
      'function' => 'message_message_process',
      'file' => 'message_plugin.inc',
      'path' => drupal_get_path('module', 'message') . '/plugins/message',
    ),
    'classes' => array('handler'),
  );

  $items['export_ui'] = array();

  return $items;
}

/**
 * Implementation of hook_nodeapi().
 */
function message_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  // Advanced implementation may want to disable the cleanup and do it
  // themselves.
  if (!variable_get('message_entity_delete_cleanup', TRUE)) {
    return;
  }
  // Preform basic clean up when a node is deleted.
  if ($op == 'delete') {
    message_deleted_entity_cleanup('node', $node->nid);
  }
}

/**
 * Implementation of hook_comment().
 */
function message_comment(&$a1, $op) {
  // Advanced implementation may want to disable the cleanup and do it
  // themselves.
  if (!variable_get('message_entity_delete_cleanup', TRUE)) {
    return;
  }
  // Preform basic clean up when a comment is deleted.
  if ($op == 'delete') {
  }
}

/**
 * Implementation of hook_user().
 */
function message_user($op, &$edit, &$account, $category = NULL) {
  // Advanced implementation may want to disable the cleanup and do it
  // themselves.
  if (!variable_get('message_entity_delete_cleanup', TRUE)) {
    return;
  }
  if ($op == 'delete') {
    // Preform basic clean up when a user is deleted.
    message_deleted_entity_cleanup('user', $account->uid);
  }
}

/**
 * Implements hook_entity_info().
 */
function message_entity_info() {
  $items['message_type'] = array(
    'label' => t('Message type'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'MessageType',
    'base table' => 'message_type',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'label' => 'description',
      'name' => 'name',
    ),
    'exportable' => TRUE,
    'bundle of' => 'message',
    'module' => 'message',
    'access callback' => 'message_type_access',
    // Enable the entity API's admin UI.
    'admin ui' => array(
      'path' => 'admin/structure/messages',
      'file' => 'message.admin.inc',
      'controller class' => 'MessageTypeUIController',
    ),
  );

  if (module_exists('locale')) {
    $items['message_type']['translation']['locale'] = TRUE;
  }

  $items['message'] = array(
    'label' => t('Message'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'Message',
    'base table' => 'message',
    'fieldable' => TRUE,
    'access callback' => 'message_access',
    'entity keys' => array(
      'id' => 'mid',
      // The message has no label.
      'label' => FALSE,
      'bundle' => 'name',
    ),
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => 'name',
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full'),
        'custom settings' => FALSE,
      ),
    ),
    'module' => 'message',
    'metadata controller class' => 'MessageMetadataController'
  );
  return $items;
}

/**
 * Implements hook_entity_info_alter().
 *
 * Use this hook to specify bundles to avoid a recursion, as loading the entity
 * message types needs the entity info too.
 */
function message_entity_info_alter(&$entity_info) {
  $message_types = entity_load('message_type');
  foreach ($message_types as $type_name => $type) {
    $entity_info['message']['bundles'][$type_name] = array(
      //@todo do we need a short label too?
      'label' => $type->name,
      'admin' => array(
        'path' => 'admin/structure/messages/manage/%message_type',
        'real path' => 'admin/structure/messages/manage/' . str_replace('_', '-', $type->name),
        'bundle argument' => 4,
        'access arguments' => array('administer messages'),
      ),
    );
  }
}

/**
 * A class used for message types.
 */
class MessageType extends Entity {

  public $name;
  public $description = '';

  public function __construct($values = array()) {
    parent::__construct($values, 'message_type');
  }
}

/**
 * Creates a new message type.
 *
 * @return MessageType
 *   Returns a new message type object.
 */
function message_type_create($name, $values = array()) {
  $values['name'] = $name;
  return entity_create('message_type', $values);
}

/**
 * Message type loader.
 *
 * @param $type_name
 *   The name for this message type.
 *
 * @return MessageType
 *   Returns a fully-loaded message type definition.
 */
function message_type_load($name = '') {
  // Replace dashes with underscores so this can be used as menu argument
  // loader too.
  $types = entity_load('message_type', isset($name) ? array(strtr($name, array('-' => '_'))) : FALSE);
  if (isset($name)) {
    return isset($types[$name]) ? $types[$name] : FALSE;
  }
  return $types;
}

/**
 * Inserts or updates a message object into the database.
 *
 * @param $message
 *   The message object to be inserted.
 *
 * @return
 *   Failure to write a record will return FALSE. Otherwise SAVED_NEW or
 *   SAVED_UPDATED is returned depending on the operation performed.
 */
function message_type_save($message) {
  return entity_save('message_type', $message);
}

/**
 * Deletes an existing message.
 *
 * @param $message
 *   The message object to be deleted.
 */
function message_type_delete($message) {
  return entity_delete('message_type', $message);
}


/**
 * A class used for messages.
 */
class Message extends Entity {

  public $name;
  public $arguments = array();
  public $timestamp;

  public function __construct($values = array()) {
    if (isset($values['user'])) {
      $values['uid'] = $values['user']->uid;
      unset($values['user']);
    }

    parent::__construct($values, 'message');
    if (!isset($this->uid)) {
      $this->uid = $GLOBALS['user']->uid;
    }
    if (!isset($this->timestamp)) {
      $this->timestamp = time();
    }
  }

  /**
   * Returns the user associated with the message.
   */
  public function user() {
    return user_load($this->uid);
  }

  /**
   * Sets a new user associated with the message.
   */
  public function setUser($account) {
    $this->uid = $account->uid;
  }

  /**
   * Gets the associated message type.
   *
   * @return MessageType
   */
  public function getType() {
    return message_type_load($this->name);
  }
}

/**
 * Helper to easily create messages.
 *
 * TODO: Document values.
 * TODO: Add separate parameter for arguments?
 */
function message_create($name, $values = array(), $account = NULL) {
  $values['name'] = $name;
  $values['user'] = $account;
  return entity_create('message', $values);
}

/**
 * Message load.
 *
 * @param $mid
 *   The message ID.
 * @return Message
 *   A message object.
 */
function message_load($mid) {
  $result = entity_load('message', array($mid));
  return $result ? reset($result) : FALSE;
}

/**
 * Loads multiple messages.
 *
 * @see entity_load().
 */
function message_load_multiple($mids, $conditions = array()) {
  return entity_load('message', $mids, $conditions);
}

/**
 * Message save.
 *
 * @param $message_instance
 *   A message instance object.
 * @return
 *   The saved message instance object.
 */
function message_save($message) {
  return entity_save('message', $message);
}

/**
 * Message delete.
 *
 * @param $iid
 *   Message instance IDs array.
 */
function message_delete_multiple($mids = array()) {
  entity_delete_multiple('message', $mids);
}

/**
 * Access callback for the message entity.
 */
function message_access($op, $entity, $account = NULL, $entity_type = 'message') {
  // @todo FIX to account for realm field.
  return TRUE;

  global $user;
  $access = FALSE;
  // Check to see if the message entity is requesting not to be displayed, as
  // might happen if an implementing module injects the "hide" property.
  if ($op == 'view' && empty($entity->hide)) {
    if (empty($account)) {
      $account = clone $user;
    }

    $property = MESSAGE_FIELD_REALM;
    if (!empty($entity->{$property}[LANGUAGE_NONE])) {
      $plugins = message_get_plugin_messages();

      // Get all the realms IDs keyed by the message realm, to save multiple
      // calls to access check.
      $realms = array();
      foreach ($entity->{$property}[LANGUAGE_NONE] as $row) {
        $realms[$row['realm']][]= $row['realm_id'];
      }

      foreach ($realms as $realm => $realm_ids) {
        $accessibale_ids = call_user_func($plugins[$realm]['access']['accessible ids callback'], $account);
        if (array_intersect($accessibale_ids, $realm_ids)) {
          $access = TRUE;
          break;
        }
      }
    }
    else {
      // No realms, so access is allowed.
      $access = TRUE;
    }
  }

  return $access;
}

/**
 * Show a message by the message entity.
 *
 * @param $message
 *   The message entity.
 * @param $skip_access
 *   Determine if access should be checked for the user. Defaults to FALSE, as
 *   access check is probably going to happen through the Views' filter system.
 * @param $account
 *   Optional; The account that access should be checked for. Defaults to the
 *   current user.
 * @param $lang
 *   Optional; The language the message should return in. Defaults to the
 *   current language.
 *
 * @return
 *   HTML with the message.
 */
function message_show_message($message, $skip_access = FALSE, $account = NULL, $lang = '') {
  $output = '';
  $access = FALSE;
  if (empty($account)) {
    global $user;
    $account = clone($user);
  }

  $access = $skip_access ? TRUE : message_access('view', $message, $account);

  if ($access) {
    $output = theme('message', array('message' => $message, 'output' => message_t($message, $lang)));
  }

  return $output;
}

/**
 * Access callback for the message type entities.
 */
function message_type_access($op, $entity, $account, $entity_type) {
  // @todo Implement permission.
  return TRUE;
}

function message_get_accessiable_realm_ids_by_plugin($plugin, $account = NULL) {
  if (empty($account)) {
    global $user;
    $account = clone $user;
  }
  return call_user_func($plugin['access']['accessible ids callback'], $account);
}

/**
 * Replace arguments with their placeholders.
 *
 * @param $message
 *   The message instance object.
 *
 * @param $language
 *   Optional; The language to get the text in. If not set the current language
 *   will be used.
 *
 * @see t().
 */
function message_t($message, $lang = '') {
  global $language;

  if (empty($lang)) {
    $lang = $language->language;
  }

  $property = MESSAGE_FIELD_MESSAGE_TEXT;
  // Get the message type.
  $message_type = message_type_load($message->name);

  $string = !empty($message_type->{$property}[$lang][0]['value']) ? $message_type->{$property}[$lang][0]['value'] : '';

  if (empty($message->arguments)) {
    return $string;
  }
  else {
    // Transform arguments before inserting them.
    // FIXME: Check if arguments is array or text, and prepare arguments
    // accordingly.
    foreach ($message->arguments as $key => $value) {

      if (is_array($value) && !empty($value['callback']) && function_exists($value['callback'])) {
        // A replacement via callback function.
        $value = call_user_func_array($value['callback'], $value['callback arguments']);
      }

      switch ($key[0]) {
        case '@':
          // Escaped only.
          $args[$key] = check_plain($value);
          break;

        case '%':
        default:
          // Escaped and placeholder.
          $args[$key] = theme('placeholder', $value);
          break;

        case '!':
          // Pass-through.
          $args[$key] = $value;
      }
    }
    return strtr($string, $args);
  }
}

/**
 * Theme the message.
 */
function theme_message($variables = array()) {
  $message = $variables['message'];
  $output = $variables['output'];
  return '<span class="message-type-' . str_replace('_', '-', check_plain($message->name)) .' message-id-'. $message->mid .'">'. $output .'</span>';
}

/**
 * Return an array of realms keyed by the plugin name and the realm value.
 */
function message_get_realm_types() {
  $options = &drupal_static(__FUNCTION__, array());
  if (empty($options)) {
    foreach (message_get_plugin_messages() as $plugin) {
      if (!empty($plugin['realm'])) {
        $options[$plugin['name']] = check_plain($plugin['title']);
      }
    }
  }

  return $options;
}

function message_get_plugin_message($plugin_name) {
  ctools_include('plugins');
  return ctools_get_plugins('message', 'message', $plugin_name);
}

function message_get_plugin_messages() {
  ctools_include('plugins');
  return ctools_get_plugins('message', 'message');
}

/**
 * Delete messages that are related to a a deleted entity.
 *
 * For example, if a node is deleted then all the message that are
 * related to that node will be deleted.
 *
 * @param $entity_type
 *   The entity type.
 * @param $etid
 *   The entity ID.
 *
 * @return
 *  Array with the message IDs that were deleted, or an empty array
 *  if none were found.
 */
function message_deleted_entity_cleanup($entity_type, $etid) {
  $mids = array();
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'message')
	  ->propertyCondition('etid', $etid)
	  ->propertyCondition('entity_type', $entity_type);


  if ($result = $query->execute()) {
  	// Get all the message IDs.
  	foreach ($result['message'] as $row) {
  	  $mids[] = $row->mid;
  	}
  	message_delete_multiple($mids);
  }
  return $mids;
}